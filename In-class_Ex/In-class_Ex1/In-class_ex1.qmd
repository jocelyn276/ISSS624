---
title: "In-class Exercise 1"
editor: visual
---

## Overview

This is my first In-class Exercise for ISSS624!

## Getting Started

The code chunk below will install and load tidyverse and sf packages.

```{r}
pacman::p_load(sf, tidyverse, spdep,tidyverse,tmap)
```

## 1. Import Data

### 1.1 Importing Geospatial Data into R

```{r}
hunan <- st_read(dsn = "data_1/geospatial", layer = "Hunan")
```

### 1.2 Importing attribute data in csv into R

```{r}
hunan2012 <- read_csv("data_1/aspatial/Hunan_2012.csv")
```

### 1.3 Performing relational join

The code chunk below will update the attribute table of *hunan's SpatialPolygonsDataFrame* with the attribute fields of *hunan2012 dataframe*.

```{r}
hunan <- left_join(hunan,hunan2012)
```

### 1.4 Visualising Regional Development Indicator

The code chunk below perform a basemap and choropleth map by using qtm() of tmap package.

```{r}
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("NAME_3", size=0.5)

gdppc <- qtm(hunan, "GDPPC")
tmap_arrange(basemap,gdppc,asp=1,ncol=2)
```

### 1.5 Computing Contiguity Spatial Weights

#### 1.5.1 Computing (Queen) contiguity based neighbours

The code chunk below is used to compute Queen contiguity weight matrix.

```{r}
wm_q <- poly2nb(hunan, queen = TRUE)
summary(wm_q)
```

The summary report shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area unit only with one neighbour.

The code chunk below is used to see the neighbours for the first polygon in the object.

```{r}
wm_q[[1]]
```

Polygon 1 has 5 neighbours. The numbers represent the polygon IDs as stored in hunan SpatialPolygonsDataFrame class. The code chunk below is used to retrieve the county name of Polygon ID=1.

```{r}
hunan$County[1]
```

The code chunk below is used to reveal the county names of the five neighbouring polygons.

```{r}
hunan$NAME_3[c(2,3,4,57,85)]
```

The code chunk below is used to retrieve the GDPPC of these five neighbouring counties.

```{r}
nb1 <- wm_q[[1]]
nb2 <- hunan$GDPPC[nb1]
nb2
```

We can use str() to display the complete weight matrix.

```{r}
str(wm_q)
```

#### 1.5.2 Creating (ROOK) contiguity based neighbours

The code chunk below is used to compute Rook contiguity weight matrix.

```{r}
wm_r <- poly2nb(hunan,queen = FALSE)
summary(wm_r)
```

#### 1.5.3 Visualising Contiguity Weights

A connectivity graph takes a point and displays a line to each neighboring point. The most typically method for getting points is polygon centroids. Getting Latitude and Longitude of Polygon Centroids.

A mapping function will be used. It applies a given function to each element of a vector and returns a vector of the same length. The [map](https://purrr.tidyverse.org/reference/map.html) documentation.

```{r}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
```

```{r}
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
```

We use cbind to put longitude and latitude into the same object.

```{r}
coords <- cbind(longitude, latitude)
head(coords)
```

##### 1.5.3.1 Plotting Queen contiguity based neighbours map

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch=19, cex=0.6, add=TRUE, col="Red")
```

##### 1.5.3.2 Plotting Rook contiguity based neighbours map

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords,pch=19,cex=0.6, add=TRUE, col="Red")
```

##### 1.5.3.3 Plotting both Queen and Rook contiguity based neighbours map

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch=19, cex=0.6, add=TRUE, col="Red")
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords,pch=19,cex=0.6, add=TRUE, col="Red")
```

## 1.6 Computing distance based neighbours

In this section, I learned how to use [dnearneigh()](https://r-spatial.github.io/spdep/reference/dnearneigh.html) to derive distance-based weight matrices.

### 1.6.1 Determine the cut-off distance

Firstly, we need to determine the upper limit for distance band.

-   Use **knearneigh()** to return a matrix with the indices of points belonging to the set of the k nearest neighbors of each other.

-   Use **knn2nb()** to convert the knn object returned by knearneigh() into a neighbor list of class nb with a list of integer vectors containing neighbour region number ids.

-   Use **nbdists()** to return the length of neighbour relationship edges. The function returns in the units of the coordinates if the coordinates are projected, otherwise in **km**.

-   Use **unlist()** to remove the list structure of the returned object.

```{r}
#coords <- coordinates(hunan)
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

The largest first nearest neighbor distance is 61.79km, and we will set 62km as the upper distance bound.

### 1.6.2 Computing fixed distance weight matrix

The code chunk below is used to compute the distance weight matrix.

```{r}
wm_d62 <- dnearneigh(coords,0,62,longlat = TRUE)
wm_d62
```

Next, use *str()* to display the content of wm_d62 weight matrix.

```{r}
str(wm_d62)
```

Another way to dispaly the structure of the weight matrix is combine *table()* and *card()*.

```{r}
table(hunan$County, card(wm_d62))
```

```{r}
n_comp <- n.comp.nb(wm_d62)
n_comp$nc
```

```{r}
table(n_comp$comp.id)
```

#### 1.6.2.1 Plotting fixed distance weight matrix
